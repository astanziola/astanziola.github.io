<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Acoustic Hologram Optimisation Using Automatic Differentiation in JAX | Antonio Stanziola</title> <meta name="author" content="Antonio Stanziola"/> <meta name="description" content="efficient implementation of the Fushimi at al. using jax"/> <meta name="keywords" content="ultrasound, deep learning, jax, differentiable programming, simulation, medical imaging"/> <meta property="og:site_name" content="Antonio Stanziola"/> <meta property="og:type" content="website"/> <meta property="og:title" content="Antonio Stanziola | Acoustic Hologram Optimisation Using Automatic Differentiation in JAX"/> <meta property="og:url" content="https://astanziola.github.io/blog/2022/diff-pat-in-jax/"/> <meta property="og:description" content="efficient implementation of the Fushimi at al. using jax"/> <meta property="og:locale" content="en"/> <meta name="twitter:card" content="summary"/> <meta name="twitter:title" content="Acoustic Hologram Optimisation Using Automatic Differentiation in JAX"/> <meta name="twitter:description" content="efficient implementation of the Fushimi at al. using jax"/> <meta name="twitter:site" content="@astanziola42"/> <meta name="twitter:creator" content="@astanziola42"/> <script type="application/ld+json">
      {
        "author":
        {
          "@type": "Person",
          "name": "Antonio  Stanziola"
        },
        "url": "https://astanziola.github.io/blog/2022/diff-pat-in-jax/",
        "@type": "WebSite",
        "description": "efficient implementation of the Fushimi at al. using jax",
        "headline": "Acoustic Hologram Optimisation Using Automatic Differentiation in JAX",
        "sameAs": ["https://orcid.org/0000-0001-7035-5489", "https://scholar.google.com/citations?user=janVBUgAAAAJ", "https://publons.com/a/3428004/", "https://github.com/astanziola", "https://www.linkedin.com/in/antonio-stanziola-9a3645239", "https://twitter.com/astanziola42"],
        "name": "Antonio  Stanziola",
        "@context": "https://schema.org"
      }
    </script> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"/> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="none" id="highlight_theme_light"/> <link rel="shortcut icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üêô</text></svg>"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://astanziola.github.io/blog/2022/diff-pat-in-jax/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"/> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav sticky-bottom-footer"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Antonio¬†</span>Stanziola</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv</a> </li> <li class="nav-item "> <a class="nav-link" href="/outreach/">outreach</a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">links</a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item" href="https://astanziola.github.io/ml-us-deadlines">ML and US conferences</a> </div> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Acoustic Hologram Optimisation Using Automatic Differentiation in JAX</h1> <p class="post-meta">August 1, 2022</p> <p class="post-tags"> <a href="/blog/2022"> <i class="fas fa-calendar fa-sm"></i> 2022 </a> ¬† ¬∑ ¬† <a href="/blog/tag/implementation"> <i class="fas fa-hashtag fa-sm"></i> implementation</a> ¬† <a href="/blog/tag/acoustics"> <i class="fas fa-hashtag fa-sm"></i> acoustics</a> ¬† <a href="/blog/tag/jax"> <i class="fas fa-hashtag fa-sm"></i> jax</a> ¬† ¬† ¬∑ ¬† <a href="/blog/category/code-examples"> <i class="fas fa-tag fa-sm"></i> code-examples</a> ¬† </p> </header> <article class="post-content"> <p>On December 2020, Tatsuki Fushimi, Kenta Yamamoto &amp; Yoichi Ochiai have <a href="https://arxiv.org/abs/2012.02431" target="_blank" rel="noopener noreferrer">submitted a preprint</a>, later accepted by <a href="https://www.nature.com/articles/s41598-021-91880-2" target="_blank" rel="noopener noreferrer">Scientific Reports</a>, on using <strong>automatic differentiation</strong> for the optimization of acoustic holograms produced by phased arrays.</p> <p>In the following, we will implement the main algorithm discussed in the paper using <a href="https://jax.readthedocs.io/en/latest/" target="_blank" rel="noopener noreferrer">jax</a>: this work provides a good case study for demonstrating the use of <a href="https://jax.readthedocs.io/en/latest/" target="_blank" rel="noopener noreferrer">jax</a> for scientific applications not related to machine learning.</p> <h2 id="problem-setup">Problem setup</h2> <p>Assume to have a transducer located in \(x_t\), which is transmitting a monochromatic (single frequency) signal with wavenumber</p> \[k = \frac{2\pi f_0}{c_0},\] <p>where \(f_0\) is the transmit frequency and \(c_0\) is the speed of sound of the homogeneous medium. Then one can use a simplified version of the <strong>Rayleigh integral</strong> (see <a href="https://pubmed.ncbi.nlm.nih.gov/26428789/" target="_blank" rel="noopener noreferrer">[Sapozhnikov et al., 2015]</a> for a more general discussion) to calculate the pressure field at a location \(x_c\)</p> \[p_{c,t} = \frac{P_{ref}}{\|x_c - x_t\|}D(\theta)e^{j(k\|x_t-x_c\|+ \phi_t)}\] <p>where \(P_{ref}\) is the pressure amplitude at the transducer, \(\phi_t\) is the phase of the transmit wave and</p> \[D(\theta) = \frac{2J_1(k r \sin(\theta))}{k r \sin(\theta)}\] <p>is the directivity factor which depends on the angle \(\theta\) between the transducer normal and the vector \(x_t-x_c\). Here, the function \(J_1\) is the Bessel function of the first kind of order 1.</p> <p>Note that the pressure is expressed as a <strong>complex number</strong>, as it is customary for time harmonic fields, in order to implicitly define the phase relationships between the field at various locations.</p> <p>The last step is to use the <strong>superposition</strong> property deriving from the <a href="https://en.wikipedia.org/wiki/Superposition_principle#Wave_superposition" target="_blank" rel="noopener noreferrer">linearity of the wave equation</a> to sum the contribution of \(M\) transducers in the phased array to the field</p> \[p(x_c) = \sum_{t=1}^{M} p_{c,t}\] <h3 id="optimization">Optimization</h3> <p>All is left to use automatic differentiation is to define a loss function. The authors have chosen to optimize the <strong>amplitude</strong> \(\|p(x_c)\|\) of the field by matching it against some known positive field \(A(x_c)\). Using a squared error distance, this reduces the loss function to</p> \[\mathcal L(p) = \frac{1}{|\Omega|}\int_\Omega (A(x) - |p(x)|)^2 dx \propto \sum_{x_c \in X} (A(x) - |p(x)|)^2\] <p>for an appropriate dense set of positions \(X\), which we will take as equispaced points (i.e. pixels) to directly compare the field with a digital image.</p> <h2 id="implementation">Implementation</h2> <p>First of all, let‚Äôs import the required libraries:</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="n">jax</span>
<span class="kn">from</span> <span class="n">jax</span> <span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">jnp</span>
<span class="kn">from</span> <span class="n">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span></code></pre></figure> <p>Afterwards, we define some parameters that we will use throughout the following sections.</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c1"># Free parameters
</span><span class="n">c0</span> <span class="o">=</span> <span class="mi">346</span>                <span class="c1"># Air speed of sound
</span><span class="n">f0</span> <span class="o">=</span> <span class="mf">40e3</span>               <span class="c1"># Transmit frequency
</span><span class="n">radius</span> <span class="o">=</span> <span class="mf">0.005</span>          <span class="c1"># Radius of the transducer
</span><span class="n">z_plane</span> <span class="o">=</span> <span class="mf">0.1</span>           <span class="c1"># Distance between transducer and target field
</span><span class="n">k</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">jnp</span><span class="p">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f0</span><span class="o">/</span><span class="n">c0</span>      <span class="c1"># Wavenumber
</span>
<span class="c1"># Generating transducer positions
</span><span class="n">x_pos</span><span class="p">,</span> <span class="n">y_pos</span> <span class="o">=</span> <span class="nf">map</span><span class="p">(</span>
    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">jnp</span><span class="p">.</span><span class="nf">mean</span><span class="p">(</span><span class="n">x</span><span class="p">)).</span><span class="nf">flatten</span><span class="p">()</span><span class="o">*</span><span class="n">radius</span><span class="p">,</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">indices</span><span class="p">((</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">))</span>
<span class="p">)</span>
<span class="n">z_pos</span> <span class="o">=</span> <span class="n">x_pos</span><span class="o">*</span><span class="mi">0</span>         <span class="c1"># Tranducers on x_y plane, z = 0
</span><span class="n">positions</span> <span class="o">=</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">stack</span><span class="p">([</span><span class="n">x_pos</span><span class="p">,</span> <span class="n">y_pos</span><span class="p">,</span> <span class="n">z_pos</span><span class="p">],</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Evaluating normals
</span><span class="n">normals</span> <span class="o">=</span> <span class="p">(</span><span class="n">positions</span><span class="o">*</span><span class="mi">0</span><span class="p">).</span><span class="n">at</span><span class="p">[:,</span><span class="mi">2</span><span class="p">].</span><span class="nf">set</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span> <span class="c1"># All normals along the z axis -&gt; (0,0,1)
</span>
<span class="c1"># Initializing phases to zero
</span><span class="n">phases</span> <span class="o">=</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="n">positions</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],))</span>

<span class="c1"># Sampling positions at the target plane
</span><span class="n">x_pos</span><span class="p">,</span> <span class="n">y_pos</span> <span class="o">=</span> <span class="nf">map</span><span class="p">(</span>
    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">jnp</span><span class="p">.</span><span class="nf">mean</span><span class="p">(</span><span class="n">x</span><span class="p">)).</span><span class="nf">flatten</span><span class="p">()</span><span class="o">*</span><span class="n">radius</span><span class="o">/</span><span class="mi">8</span><span class="p">,</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">indices</span><span class="p">((</span><span class="mi">256</span><span class="p">,</span><span class="mi">256</span><span class="p">))</span>
<span class="p">)</span>
<span class="n">z_pos</span> <span class="o">=</span> <span class="n">x_pos</span><span class="o">*</span><span class="mi">0</span> <span class="o">+</span> <span class="n">z_plane</span>  <span class="c1"># Plane parallel to the transducers array
</span><span class="n">plane_positions</span> <span class="o">=</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">stack</span><span class="p">([</span><span class="n">x_pos</span><span class="p">,</span> <span class="n">y_pos</span><span class="p">,</span> <span class="n">z_pos</span><span class="p">],</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Some helper functions
</span><span class="n">norm</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">jnp</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">jnp</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
<span class="n">avg_norm</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">jnp</span><span class="p">.</span><span class="nf">mean</span><span class="p">(</span><span class="n">jnp</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
<span class="n">dot</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span></code></pre></figure> <h3 id="forward-functions">Forward functions</h3> <p>We can start implementing some functions! While doing that, we can focus on a single transducer and a single target point, as we will parallelize (actually, <strong>vectorize</strong>) everything later on using <a href="https://jax.readthedocs.io/en/latest/_autosummary/jax.vmap.html#jax.vmap" target="_blank" rel="noopener noreferrer"><code class="language-plaintext highlighter-rouge">jax.vmap</code></a>.</p> <p>The first function evaluates the angle \(\theta\) between a transducer normal and a target location, simply by using the arc-cosine of their normalized dot product:</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">angle_between</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">arccos</span><span class="p">(</span><span class="nf">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="nf">norm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="nf">norm</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span></code></pre></figure> <p>At this point, we hit the first problem: we need the Bessel function of the first kind of order 1 to evaluate the directivity factor, but it looks like JAX doesn‚Äôt have it! However, <a href="https://en.wikipedia.org/wiki/Bessel_function" target="_blank" rel="noopener noreferrer">according to Wikipedia</a> it holds the relationship</p> \[-J_1(x) = \frac{\partial}{\partial x} J_0(x)\] <p>where \(J_0(x)\) is the Bessel function of the first kind of order 0, which is implemented by jax in <code class="language-plaintext highlighter-rouge">jax.numpy.i0</code>. So we can implement the Bessel function of the first kind using autodiff with <code class="language-plaintext highlighter-rouge">jax.grad</code> (I‚Äôm 99% sure this is correct, but I‚Äôm not sure):</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">J1</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">J0</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">i0</span><span class="p">(</span><span class="o">-</span><span class="mf">1j</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">jax</span><span class="p">.</span><span class="nf">grad</span><span class="p">(</span><span class="n">J0</span><span class="p">)(</span><span class="n">x</span><span class="p">).</span><span class="n">real</span></code></pre></figure> <p>At this point, we can write the directivity function \(D(\theta)\) as</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">directivity_fun</span><span class="p">(</span><span class="n">theta</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">k</span><span class="o">*</span><span class="n">radius</span><span class="o">*</span><span class="n">jnp</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">D_with_nans</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="nc">J1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span>
    <span class="k">return</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="n">jnp</span><span class="p">.</span><span class="nf">isnan</span><span class="p">(</span><span class="n">D_with_nans</span><span class="p">),</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">D_with_nans</span><span class="p">)</span></code></pre></figure> <p>Having all the main ingredients setup, we can finally write the function that evaluates the beam-pattern of a single transducer (at a single location)</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">p_c</span><span class="p">(</span><span class="n">x_c</span><span class="p">,</span> <span class="n">x_t</span><span class="p">,</span> <span class="n">normal_vec</span><span class="p">,</span> <span class="n">phase</span><span class="p">):</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="nf">angle_between</span><span class="p">(</span><span class="n">x_c</span><span class="p">,</span> <span class="n">normal_vec</span><span class="p">)</span>
    <span class="n">D</span> <span class="o">=</span> <span class="nf">directivity_fun</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="nf">norm</span><span class="p">(</span><span class="n">x_c</span> <span class="o">-</span> <span class="n">x_t</span><span class="p">)</span>
    <span class="n">output_phase</span> <span class="o">=</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="mf">1j</span><span class="o">*</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">dist</span> <span class="o">+</span> <span class="n">phase</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">D</span><span class="o">*</span><span class="n">output_phase</span><span class="o">/</span><span class="n">dist</span></code></pre></figure> <h3 id="vectorization">Vectorization</h3> <p>Adding the contribution of all the transducers can be easily done by vectorizing the function above with respect to the input positions, using <code class="language-plaintext highlighter-rouge">jax.vmap</code>, and summing them all:</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">p_tot</span><span class="p">(</span><span class="n">xc</span><span class="p">,</span> <span class="n">xt</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">phases</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span>
        <span class="n">jax</span><span class="p">.</span><span class="nf">vmap</span><span class="p">(</span><span class="n">p_c</span><span class="p">,</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">)(</span><span class="n">xc</span><span class="p">,</span> <span class="n">xt</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">phases</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span></code></pre></figure> <p>Similarly, we can get the field at all the positions by vectorizing the function above with respect to the target location <code class="language-plaintext highlighter-rouge">x_c</code></p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">pc_vect</span> <span class="o">=</span> <span class="n">jax</span><span class="p">.</span><span class="nf">vmap</span><span class="p">(</span><span class="n">p_tot</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">get_hologram</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="nf">pc_vect</span><span class="p">(</span><span class="n">plane_positions</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span><span class="n">normals</span><span class="p">,</span><span class="n">x</span><span class="p">),</span> <span class="p">(</span><span class="mi">256</span><span class="p">,</span><span class="mi">256</span><span class="p">))</span></code></pre></figure> <p>Let‚Äôs look at the hologram for the initial, flat phase distribution</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">p</span> <span class="o">=</span> <span class="nf">get_hologram</span><span class="p">(</span><span class="n">phases</span><span class="p">)</span></code></pre></figure> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/diff_pat/flat_beampattern-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/diff_pat/flat_beampattern-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/diff_pat/flat_beampattern-1400.webp"></source> <img src="/assets/img/diff_pat/flat_beampattern.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> </div> </div> <h2 id="loss-function">Loss function</h2> <p>Let‚Äôs start with a very simple image that we are trying to match</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="n">jax.example_libraries</span> <span class="kn">import</span> <span class="n">optimizers</span>
<span class="kn">from</span> <span class="n">jax</span> <span class="kn">import</span> <span class="n">random</span>

<span class="c1"># Constructing reference image
</span><span class="n">reference_hologram</span> <span class="o">=</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="mi">256</span><span class="p">,</span><span class="mi">256</span><span class="p">))</span>
<span class="n">reference_hologram</span> <span class="o">=</span> <span class="n">reference_hologram</span><span class="p">.</span><span class="n">at</span><span class="p">[</span><span class="mi">32</span><span class="p">:</span><span class="mi">64</span><span class="p">,</span><span class="mi">48</span><span class="p">:</span><span class="mi">164</span><span class="p">].</span><span class="nf">set</span><span class="p">(.</span><span class="mi">5</span><span class="p">)</span>
<span class="n">reference_hologram</span> <span class="o">=</span> <span class="n">reference_hologram</span><span class="p">.</span><span class="n">at</span><span class="p">[</span><span class="mi">64</span><span class="p">:</span><span class="mi">200</span><span class="p">,</span><span class="mi">128</span><span class="p">:</span><span class="mi">164</span><span class="p">].</span><span class="nf">set</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span>
<span class="n">reference_hologram</span> <span class="o">=</span> <span class="n">reference_hologram</span><span class="p">.</span><span class="n">at</span><span class="p">[</span><span class="mi">96</span><span class="p">:</span><span class="mi">128</span><span class="p">,</span><span class="mi">164</span><span class="p">:</span><span class="mi">150</span><span class="p">].</span><span class="nf">set</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span>
<span class="n">reference_hologram</span> <span class="o">=</span> <span class="n">reference_hologram</span><span class="p">.</span><span class="n">at</span><span class="p">[</span><span class="mi">150</span><span class="p">:</span><span class="mi">210</span><span class="p">,</span><span class="mi">128</span><span class="p">:</span><span class="mi">164</span><span class="p">].</span><span class="nf">set</span><span class="p">(.</span><span class="mi">3</span><span class="p">)</span>
<span class="n">reference_hologram</span> <span class="o">=</span> <span class="n">reference_hologram</span><span class="p">.</span><span class="n">at</span><span class="p">[</span><span class="mi">150</span><span class="p">:</span><span class="mi">190</span><span class="p">,</span><span class="mi">64</span><span class="p">:</span><span class="mi">100</span><span class="p">].</span><span class="nf">set</span><span class="p">(.</span><span class="mi">7</span><span class="p">)</span>
<span class="n">reference_hologram</span> <span class="o">=</span> <span class="n">reference_hologram</span><span class="p">.</span><span class="n">at</span><span class="p">[</span><span class="mi">200</span><span class="p">:</span><span class="mi">230</span><span class="p">,</span><span class="mi">64</span><span class="p">:</span><span class="mi">200</span><span class="p">].</span><span class="nf">set</span><span class="p">(.</span><span class="mi">2</span><span class="p">)</span></code></pre></figure> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/diff_pat/reference_pattern-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/diff_pat/reference_pattern-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/diff_pat/reference_pattern-1400.webp"></source> <img src="/assets/img/diff_pat/reference_pattern.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> </div> </div> <p>We are going to optimize a slightly different loss function than the Diff-PAT paper, namely the cross correlation, defined as</p> \[\mathcal L = \sum_i A(x_i) |p(x_i)|\] <p>which is implemented as</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">xcorr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="o">-</span><span class="nf">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="nf">norm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="nf">norm</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">lossfun</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="nf">xcorr</span><span class="p">(</span><span class="n">jnp</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="nf">get_hologram</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">reference_hologram</span><span class="p">)</span></code></pre></figure> <p>Note that the loss function depends on the vector of phases for each transducer. To optimize it, we get the gradient using autodiff</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">loss_with_grad</span> <span class="o">=</span> <span class="n">jax</span><span class="p">.</span><span class="nf">value_and_grad</span><span class="p">(</span><span class="n">lossfun</span><span class="p">)</span></code></pre></figure> <h2 id="optimization-1">Optimization</h2> <p>We are now all setup to optimize the loss function. All we need is an updated function that takes the current vector of phases and updates it using the gradient. We will use the Adam optimizer, as in the Diff-PAT paper.</p> <p>As it is customary in JAX, we can use the <code class="language-plaintext highlighter-rouge">jax.jit</code> to just-in-time compile this function for faster execution.</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c1"># Initialize optimizer
</span><span class="n">init_fun</span><span class="p">,</span> <span class="n">update_fun</span><span class="p">,</span> <span class="n">get_params</span> <span class="o">=</span> <span class="n">optimizers</span><span class="p">.</span><span class="nf">adam</span><span class="p">(.</span><span class="mi">2</span><span class="p">)</span>
<span class="n">opt_state</span> <span class="o">=</span> <span class="nf">init_fun</span><span class="p">(</span><span class="n">phases</span><span class="p">)</span>

<span class="nd">@jax.jit</span>
<span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">opt_state</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">iteration</span><span class="p">):</span>
    <span class="n">params</span> <span class="o">=</span> <span class="nf">get_params</span><span class="p">(</span><span class="n">opt_state</span><span class="p">)</span>
    <span class="n">lossval</span><span class="p">,</span> <span class="n">gradient</span> <span class="o">=</span> <span class="nf">loss_with_grad</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">lossval</span><span class="p">,</span> <span class="nf">update_fun</span><span class="p">(</span><span class="n">iteration</span><span class="p">,</span> <span class="n">gradient</span><span class="p">,</span> <span class="n">opt_state</span><span class="p">)</span></code></pre></figure> <p>All is left to do now is to wrap the <code class="language-plaintext highlighter-rouge">update</code> function in a loop that runs for a number of iterations. Note that we explicitly define a random seed for the random number generator, since this aids reproducibility and is anyhow necessary in JAX.</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">losshistory</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">key</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nc">PRNGKey</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>

<span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="n">lossval</span><span class="p">,</span> <span class="n">opt_state</span> <span class="o">=</span> <span class="nf">update</span><span class="p">(</span><span class="n">opt_state</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">iteration</span><span class="p">)</span>
    
    <span class="c1"># For logging
</span>    <span class="n">losshistory</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="o">-</span><span class="n">lossval</span><span class="p">)</span></code></pre></figure> <h2 id="results">Results</h2> <p>After the optimization is over, which should be relatively fast especially if you are running <code class="language-plaintext highlighter-rouge">jax</code> on a GPU, we can visualize the results:</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/diff_pat/optimized_beampattern-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/diff_pat/optimized_beampattern-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/diff_pat/optimized_beampattern-1400.webp"></source> <img src="/assets/img/diff_pat/optimized_beampattern.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/diff_pat/phase_encoding-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/diff_pat/phase_encoding-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/diff_pat/phase_encoding-1400.webp"></source> <img src="/assets/img/diff_pat/phase_encoding.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/diff_pat/corr_coefficient-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/diff_pat/corr_coefficient-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/diff_pat/corr_coefficient-1400.webp"></source> <img src="/assets/img/diff_pat/corr_coefficient.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>It is fairly close to the target hologram, but not quite. One could experiment with different loss functions, or with different initial phases. Note however that we are currently only controlling the phase of the transducers. If one could also control the amplitude, than the wave propagator is a <strong>linear operator</strong> of the complex input parameters \(P_{t}e^{j\theta_t}\), making the MSE optimization problem convex and therefore uniquely solvable (up to a global phase shift).</p> <h2 id="conclusions">Conclusions</h2> <p>In this tutorial, we have reproduced the Diff-PAT algorithm, and we have shown how JAX can be used to easily and efficiently prototype algorithms that are relevant for numerical physics methods, by exploiting its ability to conveniently transform functions in several ways.</p> <p>A jupyter notebook implementing this tutorial can be found <a href="https://github.com/astanziola/diff-pat-jax" target="_blank" rel="noopener noreferrer">at the following GitHub repo</a>.</p> <p>The findings from Fushimi et al. could also be extended in a number of ways. For example, the hologram produced by a planar wavefront could be efficiently propagated in the Fourier domain: this is implemented in the <a href="https://github.com/ucl-bug/jwave/blob/e8884856b0cf88c5fe7ede5e003d98143c8973e5/jwave/acoustics/time_harmonic.py#L17" target="_blank" rel="noopener noreferrer"><code class="language-plaintext highlighter-rouge">angular_spectrum</code></a> function of the <code class="language-plaintext highlighter-rouge">jwave</code> package.</p> <h3 id="references">References</h3> <ul> <li>Fushimi, T., Yamamoto, K. &amp; Ochiai, Y. <strong>Acoustic hologram optimisation using automatic differentiation.</strong> Sci Rep 11, 12678 (2021). <a href="https://www.nature.com/articles/s41598-021-91880-2" target="_blank" rel="noopener noreferrer">https://doi.org/10.1038/s41598-021-91880-2</a> </li> </ul> </article> </div> </div> <footer class="sticky-bottom mt-5"> <div class="container"> ¬© Copyright 2024 Antonio Stanziola. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="noopener noreferrer">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" target="_blank" rel="noopener noreferrer">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="noopener noreferrer">GitHub Pages</a>. Last updated: July 29, 2024. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="/assets/js/common.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> </body> </html>